{"ast":null,"code":"// GAME_PIXEL_COUNT is the pixels on horizontal or vertical axis of the game board (SQUARE).\nconst GAME_PIXEL_COUNT = 40;\nconst SQUARE_OF_GAME_PIXEL_COUNT = Math.pow(GAME_PIXEL_COUNT, 2);\n_c = SQUARE_OF_GAME_PIXEL_COUNT;\nlet totalFoodAte = 0;\nlet totalDistanceTravelled = 0;\n\n/// THE GAME BOARD:\nconst gameContainer = document.getElementById(\"gameContainer\");\nconst createGameBoardPixels = () => {\n  let gamePixelDivs = '';\n  for (let i = 1; i <= SQUARE_OF_GAME_PIXEL_COUNT; ++i) {\n    gamePixelDivs = `${gamePixelDivs} <div class=\"gameBoardPixel\" id=\"pixel${i}\"></div>`;\n  }\n  // Populate the [#gameContainer] div with small div's representing game pixels\n  gameContainer.innerHTML = `${gameContainer.innerHTML} ${gamePixelDivs}`;\n};\n\n// This variable always holds the updated array of game pixels created by createGameBoardPixels() :\nconst gameBoardPixels = document.getElementsByClassName(\"gameBoardPixel\");\n\n/// THE FOOD:\nlet currentFoodPostion = 0;\nconst createFood = () => {\n  // Remove previous food;\n  gameBoardPixels[currentFoodPostion].classList.remove(\"food\");\n\n  // Create new food\n  currentFoodPostion = Math.random();\n  currentFoodPostion = Math.floor(currentFoodPostion * SQUARE_OF_GAME_PIXEL_COUNT);\n  gameBoardPixels[currentFoodPostion].classList.add(\"food\");\n};\n\n/// THE SNAKE:\n\n// Direction codes (Keyboard key codes for arrow keys):\nconst LEFT_DIR = 37;\nconst UP_DIR = 38;\nconst RIGHT_DIR = 39;\nconst DOWN_DIR = 40;\n\n// Set snake direction initially to right\nlet snakeCurrentDirection = RIGHT_DIR;\nconst changeDirection = newDirectionCode => {\n  // Change the direction of the snake\n  if (newDirectionCode == snakeCurrentDirection) return;\n  if (newDirectionCode == LEFT_DIR && snakeCurrentDirection != RIGHT_DIR) {\n    snakeCurrentDirection = newDirectionCode;\n  } else if (newDirectionCode == UP_DIR && snakeCurrentDirection != DOWN_DIR) {\n    snakeCurrentDirection = newDirectionCode;\n  } else if (newDirectionCode == RIGHT_DIR && snakeCurrentDirection != LEFT_DIR) {\n    snakeCurrentDirection = newDirectionCode;\n  } else if (newDirectionCode == DOWN_DIR && snakeCurrentDirection != UP_DIR) {\n    snakeCurrentDirection = newDirectionCode;\n  }\n};\n\n// Let the starting position of the snake be at the middle of game board\nlet currentSnakeHeadPosition = SQUARE_OF_GAME_PIXEL_COUNT / 2;\n\n// Initial snake length\nlet snakeLength = 1000;\n\n// Move snake continously by calling this function repeatedly :\nconst moveSnake = () => {\n  switch (snakeCurrentDirection) {\n    case LEFT_DIR:\n      --currentSnakeHeadPosition;\n      const isSnakeHeadAtLastGameBoardPixelTowardsLeft = currentSnakeHeadPosition % GAME_PIXEL_COUNT == GAME_PIXEL_COUNT - 1 || currentSnakeHeadPosition < 0;\n      if (isSnakeHeadAtLastGameBoardPixelTowardsLeft) {\n        currentSnakeHeadPosition = currentSnakeHeadPosition + GAME_PIXEL_COUNT;\n      }\n      break;\n    case UP_DIR:\n      currentSnakeHeadPosition = currentSnakeHeadPosition - GAME_PIXEL_COUNT;\n      const isSnakeHeadAtLastGameBoardPixelTowardsUp = currentSnakeHeadPosition < 0;\n      if (isSnakeHeadAtLastGameBoardPixelTowardsUp) {\n        currentSnakeHeadPosition = currentSnakeHeadPosition + SQUARE_OF_GAME_PIXEL_COUNT;\n      }\n      break;\n    case RIGHT_DIR:\n      ++currentSnakeHeadPosition;\n      const isSnakeHeadAtLastGameBoardPixelTowardsRight = currentSnakeHeadPosition % GAME_PIXEL_COUNT == 0;\n      if (isSnakeHeadAtLastGameBoardPixelTowardsRight) {\n        currentSnakeHeadPosition = currentSnakeHeadPosition - GAME_PIXEL_COUNT;\n      }\n      break;\n    case DOWN_DIR:\n      currentSnakeHeadPosition = currentSnakeHeadPosition + GAME_PIXEL_COUNT;\n      const isSnakeHeadAtLastGameBoardPixelTowardsDown = currentSnakeHeadPosition > SQUARE_OF_GAME_PIXEL_COUNT - 1;\n      if (isSnakeHeadAtLastGameBoardPixelTowardsDown) {\n        currentSnakeHeadPosition = currentSnakeHeadPosition - SQUARE_OF_GAME_PIXEL_COUNT;\n      }\n      break;\n    default:\n      break;\n  }\n  let nextSnakeHeadPixel = gameBoardPixels[currentSnakeHeadPosition];\n\n  // Kill snake if it bites itself:\n  if (nextSnakeHeadPixel.classList.contains(\"snakeBodyPixel\")) {\n    // Stop moving the snake\n    clearInterval(moveSnakeInterval);\n    if (!alert(`You have ate ${totalFoodAte} food by travelling ${totalDistanceTravelled} blocks.`)) window.location.reload();\n  }\n  nextSnakeHeadPixel.classList.add(\"snakeBodyPixel\");\n  setTimeout(() => {\n    nextSnakeHeadPixel.classList.remove(\"snakeBodyPixel\");\n  }, snakeLength);\n\n  // Update total distance travelled\n  totalDistanceTravelled++;\n  // Update in UI:\n  document.getElementById(\"blocksTravelled\").innerHTML = totalDistanceTravelled;\n  if (currentSnakeHeadPosition == currentFoodPostion) {\n    // Update total food ate\n    totalFoodAte++;\n    // Update in UI:\n    document.getElementById(\"pointsEarned\").innerHTML = totalFoodAte;\n\n    // Increase Snake length:\n    snakeLength = snakeLength + 100;\n    createFood();\n  }\n};\n\n/// CALL THE FOLLOWING FUNCTIONS TO RUN THE GAME:\n\n// Create game board pixels:\ncreateGameBoardPixels();\n\n// Create initial food:\ncreateFood();\n\n// Move snake:\nvar moveSnakeInterval = setInterval(moveSnake, 80);\n\n// Call change direction function on keyboard key-down event:\naddEventListener(\"keydown\", e => changeDirection(e.keyCode));\n\n// ON SCREEN CONTROLLERS:\nconst leftButton = document.getElementById(\"leftButton\");\nconst rightButton = document.getElementById(\"rightButton\");\nconst upButton = document.getElementById(\"upButton\");\nconst downButton = document.getElementById(\"downButton\");\nleftButton.onclick = () => changeDirection(LEFT_DIR);\nrightButton.onclick = () => changeDirection(RIGHT_DIR);\nupButton.onclick = () => changeDirection(UP_DIR);\ndownButton.onclick = () => changeDirection(DOWN_DIR);\nvar _c;\n$RefreshReg$(_c, \"SQUARE_OF_GAME_PIXEL_COUNT\");","map":{"version":3,"names":["GAME_PIXEL_COUNT","SQUARE_OF_GAME_PIXEL_COUNT","Math","pow","_c","totalFoodAte","totalDistanceTravelled","gameContainer","document","getElementById","createGameBoardPixels","gamePixelDivs","i","innerHTML","gameBoardPixels","getElementsByClassName","currentFoodPostion","createFood","classList","remove","random","floor","add","LEFT_DIR","UP_DIR","RIGHT_DIR","DOWN_DIR","snakeCurrentDirection","changeDirection","newDirectionCode","currentSnakeHeadPosition","snakeLength","moveSnake","isSnakeHeadAtLastGameBoardPixelTowardsLeft","isSnakeHeadAtLastGameBoardPixelTowardsUp","isSnakeHeadAtLastGameBoardPixelTowardsRight","isSnakeHeadAtLastGameBoardPixelTowardsDown","nextSnakeHeadPixel","contains","clearInterval","moveSnakeInterval","alert","window","location","reload","setTimeout","setInterval","addEventListener","e","keyCode","leftButton","rightButton","upButton","downButton","onclick","$RefreshReg$"],"sources":["/Users/ibrahimkedir/Documents/GitHub/personal-website-2/src/game/snake.js"],"sourcesContent":["// GAME_PIXEL_COUNT is the pixels on horizontal or vertical axis of the game board (SQUARE).\nconst GAME_PIXEL_COUNT = 40;\nconst SQUARE_OF_GAME_PIXEL_COUNT = Math.pow(GAME_PIXEL_COUNT, 2);\n\nlet totalFoodAte = 0;\nlet totalDistanceTravelled = 0;\n\n/// THE GAME BOARD:\nconst gameContainer = document.getElementById(\"gameContainer\");\n\nconst createGameBoardPixels = () => {\n  let gamePixelDivs = '';\n  for (let i = 1; i <= SQUARE_OF_GAME_PIXEL_COUNT; ++i) {\n    gamePixelDivs = `${gamePixelDivs} <div class=\"gameBoardPixel\" id=\"pixel${i}\"></div>`;\n  }\n  // Populate the [#gameContainer] div with small div's representing game pixels\n  gameContainer.innerHTML = `${gameContainer.innerHTML} ${gamePixelDivs}`;\n};\n\n// This variable always holds the updated array of game pixels created by createGameBoardPixels() :\nconst gameBoardPixels = document.getElementsByClassName(\"gameBoardPixel\");\n\n/// THE FOOD:\nlet currentFoodPostion = 0;\nconst createFood = () => {\n  // Remove previous food;\n  gameBoardPixels[currentFoodPostion].classList.remove(\"food\");\n\n  // Create new food\n  currentFoodPostion = Math.random();\n  currentFoodPostion = Math.floor(\n    currentFoodPostion * SQUARE_OF_GAME_PIXEL_COUNT\n  );\n  gameBoardPixels[currentFoodPostion].classList.add(\"food\");\n};\n\n/// THE SNAKE:\n\n// Direction codes (Keyboard key codes for arrow keys):\nconst LEFT_DIR = 37;\nconst UP_DIR = 38;\nconst RIGHT_DIR = 39;\nconst DOWN_DIR = 40;\n\n// Set snake direction initially to right\nlet snakeCurrentDirection = RIGHT_DIR;\n\nconst changeDirection = (newDirectionCode) => {\n  // Change the direction of the snake\n  if (newDirectionCode == snakeCurrentDirection) return;\n\n  if (newDirectionCode == LEFT_DIR && snakeCurrentDirection != RIGHT_DIR) {\n    snakeCurrentDirection = newDirectionCode;\n  } else if (newDirectionCode == UP_DIR && snakeCurrentDirection != DOWN_DIR) {\n    snakeCurrentDirection = newDirectionCode;\n  } else if (\n    newDirectionCode == RIGHT_DIR &&\n    snakeCurrentDirection != LEFT_DIR\n  ) {\n    snakeCurrentDirection = newDirectionCode;\n  } else if (newDirectionCode == DOWN_DIR && snakeCurrentDirection != UP_DIR) {\n    snakeCurrentDirection = newDirectionCode;\n  }\n};\n\n// Let the starting position of the snake be at the middle of game board\nlet currentSnakeHeadPosition = SQUARE_OF_GAME_PIXEL_COUNT / 2;\n\n// Initial snake length\nlet snakeLength = 1000;\n\n// Move snake continously by calling this function repeatedly :\nconst moveSnake = () => {\n  switch (snakeCurrentDirection) {\n    case LEFT_DIR:\n      --currentSnakeHeadPosition;\n      const isSnakeHeadAtLastGameBoardPixelTowardsLeft =\n        currentSnakeHeadPosition % GAME_PIXEL_COUNT == GAME_PIXEL_COUNT - 1 ||\n        currentSnakeHeadPosition < 0;\n      if (isSnakeHeadAtLastGameBoardPixelTowardsLeft) {\n        currentSnakeHeadPosition = currentSnakeHeadPosition + GAME_PIXEL_COUNT;\n      }\n      break;\n    case UP_DIR:\n      currentSnakeHeadPosition = currentSnakeHeadPosition - GAME_PIXEL_COUNT;\n      const isSnakeHeadAtLastGameBoardPixelTowardsUp =\n        currentSnakeHeadPosition < 0;\n      if (isSnakeHeadAtLastGameBoardPixelTowardsUp) {\n        currentSnakeHeadPosition =\n          currentSnakeHeadPosition + SQUARE_OF_GAME_PIXEL_COUNT;\n      }\n      break;\n    case RIGHT_DIR:\n      ++currentSnakeHeadPosition;\n      const isSnakeHeadAtLastGameBoardPixelTowardsRight =\n        currentSnakeHeadPosition % GAME_PIXEL_COUNT == 0;\n      if (isSnakeHeadAtLastGameBoardPixelTowardsRight) {\n        currentSnakeHeadPosition = currentSnakeHeadPosition - GAME_PIXEL_COUNT;\n      }\n      break;\n    case DOWN_DIR:\n      currentSnakeHeadPosition = currentSnakeHeadPosition + GAME_PIXEL_COUNT;\n      const isSnakeHeadAtLastGameBoardPixelTowardsDown =\n        currentSnakeHeadPosition > SQUARE_OF_GAME_PIXEL_COUNT - 1;\n      if (isSnakeHeadAtLastGameBoardPixelTowardsDown) {\n        currentSnakeHeadPosition =\n          currentSnakeHeadPosition - SQUARE_OF_GAME_PIXEL_COUNT;\n      }\n      break;\n    default:\n      break;\n  }\n\n  let nextSnakeHeadPixel = gameBoardPixels[currentSnakeHeadPosition];\n\n  // Kill snake if it bites itself:\n  if (nextSnakeHeadPixel.classList.contains(\"snakeBodyPixel\")) {\n    // Stop moving the snake\n    clearInterval(moveSnakeInterval);\n    if (\n      !alert(\n        `You have ate ${totalFoodAte} food by travelling ${totalDistanceTravelled} blocks.`\n      )\n    )\n      window.location.reload();\n  }\n\n  nextSnakeHeadPixel.classList.add(\"snakeBodyPixel\");\n\n  setTimeout(() => {\n    nextSnakeHeadPixel.classList.remove(\"snakeBodyPixel\");\n  }, snakeLength);\n\n  // Update total distance travelled\n  totalDistanceTravelled++;\n  // Update in UI:\n  document.getElementById(\"blocksTravelled\").innerHTML = totalDistanceTravelled;\n\n  if (currentSnakeHeadPosition == currentFoodPostion) {\n    // Update total food ate\n    totalFoodAte++;\n    // Update in UI:\n    document.getElementById(\"pointsEarned\").innerHTML = totalFoodAte;\n\n    // Increase Snake length:\n    snakeLength = snakeLength + 100;\n    createFood();\n  }\n};\n\n/// CALL THE FOLLOWING FUNCTIONS TO RUN THE GAME:\n\n// Create game board pixels:\ncreateGameBoardPixels();\n\n// Create initial food:\ncreateFood();\n\n// Move snake:\nvar moveSnakeInterval = setInterval(moveSnake, 80);\n\n// Call change direction function on keyboard key-down event:\naddEventListener(\"keydown\", (e) => changeDirection(e.keyCode));\n\n// ON SCREEN CONTROLLERS:\nconst leftButton = document.getElementById(\"leftButton\");\nconst rightButton = document.getElementById(\"rightButton\");\nconst upButton = document.getElementById(\"upButton\");\nconst downButton = document.getElementById(\"downButton\");\n\nleftButton.onclick = () => changeDirection(LEFT_DIR);\nrightButton.onclick = () => changeDirection(RIGHT_DIR);\nupButton.onclick = () => changeDirection(UP_DIR);\ndownButton.onclick = () => changeDirection(DOWN_DIR);"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}